; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.50727.1 

	TITLE	C:\Users\lw8172\Documents\GitHub\HookTestBed\WDMDriverTest\WDMDriverTest\device.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??3@YAXPAX@Z					; operator delete
PUBLIC	_IoGetCurrentIrpStackLocation@4
PUBLIC	_IoSkipCurrentIrpStackLocation@4
PUBLIC	?HelloWDMAddDevice@@YGJPAU_DRIVER_OBJECT@@PAU_DEVICE_OBJECT@@@Z ; HelloWDMAddDevice
PUBLIC	?HelloWDMPnp@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@@Z	; HelloWDMPnp
PUBLIC	?HelloWDMDispatchRoutine@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@@Z ; HelloWDMDispatchRoutine
PUBLIC	?HelloWDMUnload@@YGXPAU_DRIVER_OBJECT@@@Z	; HelloWDMUnload
PUBLIC	_DriverEntry@8
PUBLIC	??_GHookHelper@@QAEPAXI@Z			; HookHelper::`scalar deleting destructor'
PUBLIC	??2@YAPAXIW4_POOL_TYPE@@@Z			; operator new
PUBLIC	_MySleep@4
PUBLIC	_ExternWorkThread@4
PUBLIC	?DefaultPnpHandler@@YGJPAU_DEVICE_EXTENSION@@PAU_IRP@@@Z ; DefaultPnpHandler
PUBLIC	?HandleRemoveDevice@@YGJPAU_DEVICE_EXTENSION@@PAU_IRP@@@Z ; HandleRemoveDevice
PUBLIC	??_C@_07OKLGPFEL@MySleep?$AA@FNODOBFM@		;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CI@FGGEEPLK@?$CK?$CK?5?$FL?$CFs?$FN?5MySleep?5IRQL?5?$DO?5APC_LEVEL@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BB@HKPGLIGD@ExternWorkThread?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BP@HECHHJL@?$FL?$CFs?$FN?5ExternWorkThread?5Running?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BN@CEGJCNKD@?$FL?$CFs?$FN?5ExternWorkThread?5Leave?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BD@EKOFGNJI@Enter?5DriverEntry?6?$AA@PBOPGDP@ ;  ?? ::PBOPGDP::`string'
PUBLIC	??_C@_0BD@JKACOMOD@Leave?5DriverEntry?6?$AA@PBOPGDP@ ;  ?? ::PBOPGDP::`string'
PUBLIC	??_C@_0BJ@EGBGEJMD@Enter?5HelloWDMAddDevice?6?$AA@NNGAKEGL@ ;  ?? ::NNGAKEGL::`string'
PUBLIC	??_C@_1CI@GBMGKAIE@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAM?$AAy?$AAW?$AAD?$AAM?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?$AA@NNGAKEGL@ ;  ?? ::NNGAKEGL::`string'
PUBLIC	??_C@_1CK@DCLOCDEE@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AAH?$AAe?$AAl?$AAl?$AAo?$AAW?$AAD?$AAM?$AA?$AA@NNGAKEGL@ ;  ?? ::NNGAKEGL::`string'
PUBLIC	??_C@_0BJ@GNFEGBFC@Leave?5HelloWDMAddDevice?6?$AA@NNGAKEGL@ ;  ?? ::NNGAKEGL::`string'
PUBLIC	??_C@_0BJ@JJHNINKM@Enter?5DefaultPnpHandler?6?$AA@NNGAKEGL@ ;  ?? ::NNGAKEGL::`string'
PUBLIC	??_C@_0BJ@LCDPKFDN@Leave?5DefaultPnpHandler?6?$AA@NNGAKEGL@ ;  ?? ::NNGAKEGL::`string'
PUBLIC	??_C@_0BK@PNHNEGHL@Enter?5HandleRemoveDevice?6?$AA@NNGAKEGL@ ;  ?? ::NNGAKEGL::`string'
PUBLIC	??_C@_0BK@HKFOKHIB@Leave?5HandleRemoveDevice?6?$AA@NNGAKEGL@ ;  ?? ::NNGAKEGL::`string'
PUBLIC	??_C@_0BD@MLKMKNJP@Enter?5HelloWDMPnp?6?$AA@NNGAKEGL@ ;  ?? ::NNGAKEGL::`string'
PUBLIC	??_C@_0BE@DFAPAMLB@CurProcessName?3?5?$CFs?6?$AA@NNGAKEGL@ ;  ?? ::NNGAKEGL::`string'
PUBLIC	??_C@_0BE@LNOGIHJB@IRP_MN_START_DEVICE?$AA@NNGAKEGL@ ;  ?? ::NNGAKEGL::`string'
PUBLIC	??_C@_0BL@BKMKKOEG@IRP_MN_QUERY_REMOVE_DEVICE?$AA@NNGAKEGL@ ;  ?? ::NNGAKEGL::`string'
PUBLIC	??_C@_0BF@CIDCHGNK@IRP_MN_REMOVE_DEVICE?$AA@NNGAKEGL@ ;  ?? ::NNGAKEGL::`string'
PUBLIC	??_C@_0BM@NHOBKHFC@IRP_MN_CANCEL_REMOVE_DEVICE?$AA@NNGAKEGL@ ;  ?? ::NNGAKEGL::`string'
PUBLIC	??_C@_0BD@OKOEKPNG@IRP_MN_STOP_DEVICE?$AA@NNGAKEGL@ ;  ?? ::NNGAKEGL::`string'
PUBLIC	??_C@_0BJ@DBBODAKD@IRP_MN_QUERY_STOP_DEVICE?$AA@NNGAKEGL@ ;  ?? ::NNGAKEGL::`string'
PUBLIC	??_C@_0BK@IHBBLJPI@IRP_MN_CANCEL_STOP_DEVICE?$AA@NNGAKEGL@ ;  ?? ::NNGAKEGL::`string'
PUBLIC	??_C@_0BO@EDNJKJCF@IRP_MN_QUERY_DEVICE_RELATIONS?$AA@NNGAKEGL@ ;  ?? ::NNGAKEGL::`string'
PUBLIC	??_C@_0BH@NJFMIPMO@IRP_MN_QUERY_INTERFACE?$AA@NNGAKEGL@ ;  ?? ::NNGAKEGL::`string'
PUBLIC	??_C@_0BK@FNPJPCCF@IRP_MN_QUERY_CAPABILITIES?$AA@NNGAKEGL@ ;  ?? ::NNGAKEGL::`string'
PUBLIC	??_C@_0BH@BAILDNEP@IRP_MN_QUERY_RESOURCES?$AA@NNGAKEGL@ ;  ?? ::NNGAKEGL::`string'
PUBLIC	??_C@_0CD@MPPOHAEF@IRP_MN_QUERY_RESOURCE_REQUIREMEN@NNGAKEGL@ ;  ?? ::NNGAKEGL::`string'
PUBLIC	??_C@_0BJ@KBKMPMKH@IRP_MN_QUERY_DEVICE_TEXT?$AA@NNGAKEGL@ ;  ?? ::NNGAKEGL::`string'
PUBLIC	??_C@_0CE@FFGNIHMK@IRP_MN_FILTER_RESOURCE_REQUIREME@NNGAKEGL@ ;  ?? ::NNGAKEGL::`string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@NNGAKEGL@			;  ?? ::NNGAKEGL::`string'
PUBLIC	??_C@_0BD@KCLCONNF@IRP_MN_READ_CONFIG?$AA@NNGAKEGL@ ;  ?? ::NNGAKEGL::`string'
PUBLIC	??_C@_0BE@MNGKLJHO@IRP_MN_WRITE_CONFIG?$AA@NNGAKEGL@ ;  ?? ::NNGAKEGL::`string'
PUBLIC	??_C@_0N@KBDCJDGM@IRP_MN_EJECT?$AA@NNGAKEGL@	;  ?? ::NNGAKEGL::`string'
PUBLIC	??_C@_0BA@JCIHPHAO@IRP_MN_SET_LOCK?$AA@NNGAKEGL@ ;  ?? ::NNGAKEGL::`string'
PUBLIC	??_C@_0BA@MPOLLMHD@IRP_MN_QUERY_ID?$AA@NNGAKEGL@ ;  ?? ::NNGAKEGL::`string'
PUBLIC	??_C@_0BO@CLJGNPDL@IRP_MN_QUERY_PNP_DEVICE_STATE?$AA@NNGAKEGL@ ;  ?? ::NNGAKEGL::`string'
PUBLIC	??_C@_0BN@FKLLPNEA@IRP_MN_QUERY_BUS_INFORMATION?$AA@NNGAKEGL@ ;  ?? ::NNGAKEGL::`string'
PUBLIC	??_C@_0CB@EEGIBKLH@IRP_MN_DEVICE_USAGE_NOTIFICATION@NNGAKEGL@ ;  ?? ::NNGAKEGL::`string'
PUBLIC	??_C@_0BI@JJMGKCHF@IRP_MN_SURPRISE_REMOVAL?$AA@NNGAKEGL@ ;  ?? ::NNGAKEGL::`string'
PUBLIC	??_C@_0BC@PKHHAJGP@PNP?5Request?5?$CI?$CFs?$CJ?6?$AA@NNGAKEGL@ ;  ?? ::NNGAKEGL::`string'
PUBLIC	??_C@_0BD@BLELCMOE@Leave?5HelloWDMPnp?6?$AA@NNGAKEGL@ ;  ?? ::NNGAKEGL::`string'
PUBLIC	??_C@_0BP@GCFKMKJE@Enter?5HelloWDMDispatchRoutine?6?$AA@NNGAKEGL@ ;  ?? ::NNGAKEGL::`string'
PUBLIC	??_C@_0BP@EANEFCAA@Leave?5HelloWDMDispatchRoutine?6?$AA@NNGAKEGL@ ;  ?? ::NNGAKEGL::`string'
PUBLIC	??_C@_0BG@GJALPNMI@Enter?5HelloWDMUnload?6?$AA@NNGAKEGL@ ;  ?? ::NNGAKEGL::`string'
PUBLIC	??_C@_0BG@CNFJKEHI@Leave?5HelloWDMUnload?6?$AA@NNGAKEGL@ ;  ?? ::NNGAKEGL::`string'
EXTRN	__imp__RtlInitUnicodeString@8:PROC
EXTRN	_DbgPrint:PROC
EXTRN	__imp__KeGetCurrentIrql@0:PROC
EXTRN	__imp__KeDelayExecutionThread@12:PROC
EXTRN	__imp__KeQuerySystemTime@4:PROC
EXTRN	__imp__ExAllocatePool@8:PROC
EXTRN	__imp__ExFreePool@4:PROC
EXTRN	__imp__PsCreateSystemThread@28:PROC
EXTRN	__imp__PsTerminateSystemThread@4:PROC
EXTRN	__imp__IoAttachDeviceToDeviceStack@8:PROC
EXTRN	__imp_@IofCallDriver@8:PROC
EXTRN	__imp_@IofCompleteRequest@8:PROC
EXTRN	__imp__IoCreateDevice@28:PROC
EXTRN	__imp__IoCreateSymbolicLink@8:PROC
EXTRN	__imp__IoDeleteDevice@4:PROC
EXTRN	__imp__IoDeleteSymbolicLink@4:PROC
EXTRN	__imp__IoDetachDevice@4:PROC
EXTRN	__imp__IoGetCurrentProcess@0:PROC
EXTRN	??0HookHelper@@QAE@XZ:PROC			; HookHelper::HookHelper
EXTRN	??1HookHelper@@QAE@XZ:PROC			; HookHelper::~HookHelper
EXTRN	?HookNtCreateProcess@HookHelper@@QAEEPAPAX@Z:PROC ; HookHelper::HookNtCreateProcess
EXTRN	__allmul:PROC
;	COMDAT ??_C@_0BG@CNFJKEHI@Leave?5HelloWDMUnload?6?$AA@NNGAKEGL@
PAGE$s	SEGMENT
??_C@_0BG@CNFJKEHI@Leave?5HelloWDMUnload?6?$AA@NNGAKEGL@ DB 'Leave HelloW'
	DB	'DMUnload', 0aH, 00H				;  ?? ::NNGAKEGL::`string'
PAGE$s	ENDS
;	COMDAT ??_C@_0BG@GJALPNMI@Enter?5HelloWDMUnload?6?$AA@NNGAKEGL@
PAGE$s	SEGMENT
??_C@_0BG@GJALPNMI@Enter?5HelloWDMUnload?6?$AA@NNGAKEGL@ DB 'Enter HelloW'
	DB	'DMUnload', 0aH, 00H				;  ?? ::NNGAKEGL::`string'
PAGE$s	ENDS
;	COMDAT ??_C@_0BP@EANEFCAA@Leave?5HelloWDMDispatchRoutine?6?$AA@NNGAKEGL@
PAGE$s	SEGMENT
??_C@_0BP@EANEFCAA@Leave?5HelloWDMDispatchRoutine?6?$AA@NNGAKEGL@ DB 'Lea'
	DB	've HelloWDMDispatchRoutine', 0aH, 00H	;  ?? ::NNGAKEGL::`string'
PAGE$s	ENDS
;	COMDAT ??_C@_0BP@GCFKMKJE@Enter?5HelloWDMDispatchRoutine?6?$AA@NNGAKEGL@
PAGE$s	SEGMENT
??_C@_0BP@GCFKMKJE@Enter?5HelloWDMDispatchRoutine?6?$AA@NNGAKEGL@ DB 'Ent'
	DB	'er HelloWDMDispatchRoutine', 0aH, 00H	;  ?? ::NNGAKEGL::`string'
PAGE$s	ENDS
;	COMDAT ??_C@_0BD@BLELCMOE@Leave?5HelloWDMPnp?6?$AA@NNGAKEGL@
PAGE$s	SEGMENT
??_C@_0BD@BLELCMOE@Leave?5HelloWDMPnp?6?$AA@NNGAKEGL@ DB 'Leave HelloWDMP'
	DB	'np', 0aH, 00H				;  ?? ::NNGAKEGL::`string'
PAGE$s	ENDS
;	COMDAT ??_C@_0BC@PKHHAJGP@PNP?5Request?5?$CI?$CFs?$CJ?6?$AA@NNGAKEGL@
PAGE$s	SEGMENT
??_C@_0BC@PKHHAJGP@PNP?5Request?5?$CI?$CFs?$CJ?6?$AA@NNGAKEGL@ DB 'PNP Re'
	DB	'quest (%s)', 0aH, 00H			;  ?? ::NNGAKEGL::`string'
PAGE$s	ENDS
;	COMDAT ??_C@_0BI@JJMGKCHF@IRP_MN_SURPRISE_REMOVAL?$AA@NNGAKEGL@
PAGE$s	SEGMENT
??_C@_0BI@JJMGKCHF@IRP_MN_SURPRISE_REMOVAL?$AA@NNGAKEGL@ DB 'IRP_MN_SURPR'
	DB	'ISE_REMOVAL', 00H				;  ?? ::NNGAKEGL::`string'
PAGE$s	ENDS
;	COMDAT ??_C@_0CB@EEGIBKLH@IRP_MN_DEVICE_USAGE_NOTIFICATION@NNGAKEGL@
PAGE$s	SEGMENT
??_C@_0CB@EEGIBKLH@IRP_MN_DEVICE_USAGE_NOTIFICATION@NNGAKEGL@ DB 'IRP_MN_'
	DB	'DEVICE_USAGE_NOTIFICATION', 00H		;  ?? ::NNGAKEGL::`string'
PAGE$s	ENDS
;	COMDAT ??_C@_0BN@FKLLPNEA@IRP_MN_QUERY_BUS_INFORMATION?$AA@NNGAKEGL@
PAGE$s	SEGMENT
??_C@_0BN@FKLLPNEA@IRP_MN_QUERY_BUS_INFORMATION?$AA@NNGAKEGL@ DB 'IRP_MN_'
	DB	'QUERY_BUS_INFORMATION', 00H			;  ?? ::NNGAKEGL::`string'
PAGE$s	ENDS
;	COMDAT ??_C@_0BO@CLJGNPDL@IRP_MN_QUERY_PNP_DEVICE_STATE?$AA@NNGAKEGL@
PAGE$s	SEGMENT
??_C@_0BO@CLJGNPDL@IRP_MN_QUERY_PNP_DEVICE_STATE?$AA@NNGAKEGL@ DB 'IRP_MN'
	DB	'_QUERY_PNP_DEVICE_STATE', 00H		;  ?? ::NNGAKEGL::`string'
PAGE$s	ENDS
;	COMDAT ??_C@_0BA@MPOLLMHD@IRP_MN_QUERY_ID?$AA@NNGAKEGL@
PAGE$s	SEGMENT
??_C@_0BA@MPOLLMHD@IRP_MN_QUERY_ID?$AA@NNGAKEGL@ DB 'IRP_MN_QUERY_ID', 00H ;  ?? ::NNGAKEGL::`string'
PAGE$s	ENDS
;	COMDAT ??_C@_0BA@JCIHPHAO@IRP_MN_SET_LOCK?$AA@NNGAKEGL@
PAGE$s	SEGMENT
??_C@_0BA@JCIHPHAO@IRP_MN_SET_LOCK?$AA@NNGAKEGL@ DB 'IRP_MN_SET_LOCK', 00H ;  ?? ::NNGAKEGL::`string'
PAGE$s	ENDS
;	COMDAT ??_C@_0N@KBDCJDGM@IRP_MN_EJECT?$AA@NNGAKEGL@
PAGE$s	SEGMENT
??_C@_0N@KBDCJDGM@IRP_MN_EJECT?$AA@NNGAKEGL@ DB 'IRP_MN_EJECT', 00H ;  ?? ::NNGAKEGL::`string'
PAGE$s	ENDS
;	COMDAT ??_C@_0BE@MNGKLJHO@IRP_MN_WRITE_CONFIG?$AA@NNGAKEGL@
PAGE$s	SEGMENT
??_C@_0BE@MNGKLJHO@IRP_MN_WRITE_CONFIG?$AA@NNGAKEGL@ DB 'IRP_MN_WRITE_CON'
	DB	'FIG', 00H					;  ?? ::NNGAKEGL::`string'
PAGE$s	ENDS
;	COMDAT ??_C@_0BD@KCLCONNF@IRP_MN_READ_CONFIG?$AA@NNGAKEGL@
PAGE$s	SEGMENT
??_C@_0BD@KCLCONNF@IRP_MN_READ_CONFIG?$AA@NNGAKEGL@ DB 'IRP_MN_READ_CONFI'
	DB	'G', 00H					;  ?? ::NNGAKEGL::`string'
PAGE$s	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@NNGAKEGL@
PAGE$s	SEGMENT
??_C@_00CNPNBAHC@?$AA@NNGAKEGL@ DB 00H			;  ?? ::NNGAKEGL::`string'
PAGE$s	ENDS
;	COMDAT ??_C@_0CE@FFGNIHMK@IRP_MN_FILTER_RESOURCE_REQUIREME@NNGAKEGL@
PAGE$s	SEGMENT
??_C@_0CE@FFGNIHMK@IRP_MN_FILTER_RESOURCE_REQUIREME@NNGAKEGL@ DB 'IRP_MN_'
	DB	'FILTER_RESOURCE_REQUIREMENTS', 00H		;  ?? ::NNGAKEGL::`string'
PAGE$s	ENDS
;	COMDAT ??_C@_0BJ@KBKMPMKH@IRP_MN_QUERY_DEVICE_TEXT?$AA@NNGAKEGL@
PAGE$s	SEGMENT
??_C@_0BJ@KBKMPMKH@IRP_MN_QUERY_DEVICE_TEXT?$AA@NNGAKEGL@ DB 'IRP_MN_QUER'
	DB	'Y_DEVICE_TEXT', 00H				;  ?? ::NNGAKEGL::`string'
PAGE$s	ENDS
;	COMDAT ??_C@_0CD@MPPOHAEF@IRP_MN_QUERY_RESOURCE_REQUIREMEN@NNGAKEGL@
PAGE$s	SEGMENT
??_C@_0CD@MPPOHAEF@IRP_MN_QUERY_RESOURCE_REQUIREMEN@NNGAKEGL@ DB 'IRP_MN_'
	DB	'QUERY_RESOURCE_REQUIREMENTS', 00H		;  ?? ::NNGAKEGL::`string'
PAGE$s	ENDS
;	COMDAT ??_C@_0BH@BAILDNEP@IRP_MN_QUERY_RESOURCES?$AA@NNGAKEGL@
PAGE$s	SEGMENT
??_C@_0BH@BAILDNEP@IRP_MN_QUERY_RESOURCES?$AA@NNGAKEGL@ DB 'IRP_MN_QUERY_'
	DB	'RESOURCES', 00H				;  ?? ::NNGAKEGL::`string'
PAGE$s	ENDS
;	COMDAT ??_C@_0BK@FNPJPCCF@IRP_MN_QUERY_CAPABILITIES?$AA@NNGAKEGL@
PAGE$s	SEGMENT
??_C@_0BK@FNPJPCCF@IRP_MN_QUERY_CAPABILITIES?$AA@NNGAKEGL@ DB 'IRP_MN_QUE'
	DB	'RY_CAPABILITIES', 00H			;  ?? ::NNGAKEGL::`string'
PAGE$s	ENDS
;	COMDAT ??_C@_0BH@NJFMIPMO@IRP_MN_QUERY_INTERFACE?$AA@NNGAKEGL@
PAGE$s	SEGMENT
??_C@_0BH@NJFMIPMO@IRP_MN_QUERY_INTERFACE?$AA@NNGAKEGL@ DB 'IRP_MN_QUERY_'
	DB	'INTERFACE', 00H				;  ?? ::NNGAKEGL::`string'
PAGE$s	ENDS
;	COMDAT ??_C@_0BO@EDNJKJCF@IRP_MN_QUERY_DEVICE_RELATIONS?$AA@NNGAKEGL@
PAGE$s	SEGMENT
??_C@_0BO@EDNJKJCF@IRP_MN_QUERY_DEVICE_RELATIONS?$AA@NNGAKEGL@ DB 'IRP_MN'
	DB	'_QUERY_DEVICE_RELATIONS', 00H		;  ?? ::NNGAKEGL::`string'
PAGE$s	ENDS
;	COMDAT ??_C@_0BK@IHBBLJPI@IRP_MN_CANCEL_STOP_DEVICE?$AA@NNGAKEGL@
PAGE$s	SEGMENT
??_C@_0BK@IHBBLJPI@IRP_MN_CANCEL_STOP_DEVICE?$AA@NNGAKEGL@ DB 'IRP_MN_CAN'
	DB	'CEL_STOP_DEVICE', 00H			;  ?? ::NNGAKEGL::`string'
PAGE$s	ENDS
;	COMDAT ??_C@_0BJ@DBBODAKD@IRP_MN_QUERY_STOP_DEVICE?$AA@NNGAKEGL@
PAGE$s	SEGMENT
??_C@_0BJ@DBBODAKD@IRP_MN_QUERY_STOP_DEVICE?$AA@NNGAKEGL@ DB 'IRP_MN_QUER'
	DB	'Y_STOP_DEVICE', 00H				;  ?? ::NNGAKEGL::`string'
PAGE$s	ENDS
;	COMDAT ??_C@_0BD@OKOEKPNG@IRP_MN_STOP_DEVICE?$AA@NNGAKEGL@
PAGE$s	SEGMENT
??_C@_0BD@OKOEKPNG@IRP_MN_STOP_DEVICE?$AA@NNGAKEGL@ DB 'IRP_MN_STOP_DEVIC'
	DB	'E', 00H					;  ?? ::NNGAKEGL::`string'
PAGE$s	ENDS
;	COMDAT ??_C@_0BM@NHOBKHFC@IRP_MN_CANCEL_REMOVE_DEVICE?$AA@NNGAKEGL@
PAGE$s	SEGMENT
??_C@_0BM@NHOBKHFC@IRP_MN_CANCEL_REMOVE_DEVICE?$AA@NNGAKEGL@ DB 'IRP_MN_C'
	DB	'ANCEL_REMOVE_DEVICE', 00H			;  ?? ::NNGAKEGL::`string'
PAGE$s	ENDS
;	COMDAT ??_C@_0BF@CIDCHGNK@IRP_MN_REMOVE_DEVICE?$AA@NNGAKEGL@
PAGE$s	SEGMENT
??_C@_0BF@CIDCHGNK@IRP_MN_REMOVE_DEVICE?$AA@NNGAKEGL@ DB 'IRP_MN_REMOVE_D'
	DB	'EVICE', 00H					;  ?? ::NNGAKEGL::`string'
PAGE$s	ENDS
;	COMDAT ??_C@_0BL@BKMKKOEG@IRP_MN_QUERY_REMOVE_DEVICE?$AA@NNGAKEGL@
PAGE$s	SEGMENT
??_C@_0BL@BKMKKOEG@IRP_MN_QUERY_REMOVE_DEVICE?$AA@NNGAKEGL@ DB 'IRP_MN_QU'
	DB	'ERY_REMOVE_DEVICE', 00H			;  ?? ::NNGAKEGL::`string'
PAGE$s	ENDS
;	COMDAT ??_C@_0BE@LNOGIHJB@IRP_MN_START_DEVICE?$AA@NNGAKEGL@
PAGE$s	SEGMENT
??_C@_0BE@LNOGIHJB@IRP_MN_START_DEVICE?$AA@NNGAKEGL@ DB 'IRP_MN_START_DEV'
	DB	'ICE', 00H					;  ?? ::NNGAKEGL::`string'
PAGE$s	ENDS
;	COMDAT ?fcnname@?4??HelloWDMPnp@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@@Z@4PAPADA
_DATA	SEGMENT
?fcnname@?4??HelloWDMPnp@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@@Z@4PAPADA DD FLAT:??_C@_0BE@LNOGIHJB@IRP_MN_START_DEVICE?$AA@NNGAKEGL@ ; `HelloWDMPnp'::`5'::fcnname
	DD	FLAT:??_C@_0BL@BKMKKOEG@IRP_MN_QUERY_REMOVE_DEVICE?$AA@NNGAKEGL@
	DD	FLAT:??_C@_0BF@CIDCHGNK@IRP_MN_REMOVE_DEVICE?$AA@NNGAKEGL@
	DD	FLAT:??_C@_0BM@NHOBKHFC@IRP_MN_CANCEL_REMOVE_DEVICE?$AA@NNGAKEGL@
	DD	FLAT:??_C@_0BD@OKOEKPNG@IRP_MN_STOP_DEVICE?$AA@NNGAKEGL@
	DD	FLAT:??_C@_0BJ@DBBODAKD@IRP_MN_QUERY_STOP_DEVICE?$AA@NNGAKEGL@
	DD	FLAT:??_C@_0BK@IHBBLJPI@IRP_MN_CANCEL_STOP_DEVICE?$AA@NNGAKEGL@
	DD	FLAT:??_C@_0BO@EDNJKJCF@IRP_MN_QUERY_DEVICE_RELATIONS?$AA@NNGAKEGL@
	DD	FLAT:??_C@_0BH@NJFMIPMO@IRP_MN_QUERY_INTERFACE?$AA@NNGAKEGL@
	DD	FLAT:??_C@_0BK@FNPJPCCF@IRP_MN_QUERY_CAPABILITIES?$AA@NNGAKEGL@
	DD	FLAT:??_C@_0BH@BAILDNEP@IRP_MN_QUERY_RESOURCES?$AA@NNGAKEGL@
	DD	FLAT:??_C@_0CD@MPPOHAEF@IRP_MN_QUERY_RESOURCE_REQUIREMEN@NNGAKEGL@
	DD	FLAT:??_C@_0BJ@KBKMPMKH@IRP_MN_QUERY_DEVICE_TEXT?$AA@NNGAKEGL@
	DD	FLAT:??_C@_0CE@FFGNIHMK@IRP_MN_FILTER_RESOURCE_REQUIREME@NNGAKEGL@
	DD	FLAT:??_C@_00CNPNBAHC@?$AA@NNGAKEGL@
	DD	FLAT:??_C@_0BD@KCLCONNF@IRP_MN_READ_CONFIG?$AA@NNGAKEGL@
	DD	FLAT:??_C@_0BE@MNGKLJHO@IRP_MN_WRITE_CONFIG?$AA@NNGAKEGL@
	DD	FLAT:??_C@_0N@KBDCJDGM@IRP_MN_EJECT?$AA@NNGAKEGL@
	DD	FLAT:??_C@_0BA@JCIHPHAO@IRP_MN_SET_LOCK?$AA@NNGAKEGL@
	DD	FLAT:??_C@_0BA@MPOLLMHD@IRP_MN_QUERY_ID?$AA@NNGAKEGL@
	DD	FLAT:??_C@_0BO@CLJGNPDL@IRP_MN_QUERY_PNP_DEVICE_STATE?$AA@NNGAKEGL@
	DD	FLAT:??_C@_0BN@FKLLPNEA@IRP_MN_QUERY_BUS_INFORMATION?$AA@NNGAKEGL@
	DD	FLAT:??_C@_0CB@EEGIBKLH@IRP_MN_DEVICE_USAGE_NOTIFICATION@NNGAKEGL@
	DD	FLAT:??_C@_0BI@JJMGKCHF@IRP_MN_SURPRISE_REMOVAL?$AA@NNGAKEGL@
_DATA	ENDS
;	COMDAT ?fcntab@?1??HelloWDMPnp@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@@Z@4PAP6GJPAU_DEVICE_EXTENSION@@1@ZA
_DATA	SEGMENT
?fcntab@?1??HelloWDMPnp@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@@Z@4PAP6GJPAU_DEVICE_EXTENSION@@1@ZA DD FLAT:?DefaultPnpHandler@@YGJPAU_DEVICE_EXTENSION@@PAU_IRP@@@Z ; `HelloWDMPnp'::`2'::fcntab
	DD	FLAT:?DefaultPnpHandler@@YGJPAU_DEVICE_EXTENSION@@PAU_IRP@@@Z
	DD	FLAT:?HandleRemoveDevice@@YGJPAU_DEVICE_EXTENSION@@PAU_IRP@@@Z
	DD	FLAT:?DefaultPnpHandler@@YGJPAU_DEVICE_EXTENSION@@PAU_IRP@@@Z
	DD	FLAT:?DefaultPnpHandler@@YGJPAU_DEVICE_EXTENSION@@PAU_IRP@@@Z
	DD	FLAT:?DefaultPnpHandler@@YGJPAU_DEVICE_EXTENSION@@PAU_IRP@@@Z
	DD	FLAT:?DefaultPnpHandler@@YGJPAU_DEVICE_EXTENSION@@PAU_IRP@@@Z
	DD	FLAT:?DefaultPnpHandler@@YGJPAU_DEVICE_EXTENSION@@PAU_IRP@@@Z
	DD	FLAT:?DefaultPnpHandler@@YGJPAU_DEVICE_EXTENSION@@PAU_IRP@@@Z
	DD	FLAT:?DefaultPnpHandler@@YGJPAU_DEVICE_EXTENSION@@PAU_IRP@@@Z
	DD	FLAT:?DefaultPnpHandler@@YGJPAU_DEVICE_EXTENSION@@PAU_IRP@@@Z
	DD	FLAT:?DefaultPnpHandler@@YGJPAU_DEVICE_EXTENSION@@PAU_IRP@@@Z
	DD	FLAT:?DefaultPnpHandler@@YGJPAU_DEVICE_EXTENSION@@PAU_IRP@@@Z
	DD	FLAT:?DefaultPnpHandler@@YGJPAU_DEVICE_EXTENSION@@PAU_IRP@@@Z
	DD	FLAT:?DefaultPnpHandler@@YGJPAU_DEVICE_EXTENSION@@PAU_IRP@@@Z
	DD	FLAT:?DefaultPnpHandler@@YGJPAU_DEVICE_EXTENSION@@PAU_IRP@@@Z
	DD	FLAT:?DefaultPnpHandler@@YGJPAU_DEVICE_EXTENSION@@PAU_IRP@@@Z
	DD	FLAT:?DefaultPnpHandler@@YGJPAU_DEVICE_EXTENSION@@PAU_IRP@@@Z
	DD	FLAT:?DefaultPnpHandler@@YGJPAU_DEVICE_EXTENSION@@PAU_IRP@@@Z
	DD	FLAT:?DefaultPnpHandler@@YGJPAU_DEVICE_EXTENSION@@PAU_IRP@@@Z
	DD	FLAT:?DefaultPnpHandler@@YGJPAU_DEVICE_EXTENSION@@PAU_IRP@@@Z
	DD	FLAT:?DefaultPnpHandler@@YGJPAU_DEVICE_EXTENSION@@PAU_IRP@@@Z
	DD	FLAT:?DefaultPnpHandler@@YGJPAU_DEVICE_EXTENSION@@PAU_IRP@@@Z
	DD	FLAT:?DefaultPnpHandler@@YGJPAU_DEVICE_EXTENSION@@PAU_IRP@@@Z
_DATA	ENDS
;	COMDAT ??_C@_0BE@DFAPAMLB@CurProcessName?3?5?$CFs?6?$AA@NNGAKEGL@
PAGE$s	SEGMENT
??_C@_0BE@DFAPAMLB@CurProcessName?3?5?$CFs?6?$AA@NNGAKEGL@ DB 'CurProcess'
	DB	'Name: %s', 0aH, 00H				;  ?? ::NNGAKEGL::`string'
PAGE$s	ENDS
;	COMDAT ??_C@_0BD@MLKMKNJP@Enter?5HelloWDMPnp?6?$AA@NNGAKEGL@
PAGE$s	SEGMENT
??_C@_0BD@MLKMKNJP@Enter?5HelloWDMPnp?6?$AA@NNGAKEGL@ DB 'Enter HelloWDMP'
	DB	'np', 0aH, 00H				;  ?? ::NNGAKEGL::`string'
PAGE$s	ENDS
;	COMDAT ??_C@_0BK@HKFOKHIB@Leave?5HandleRemoveDevice?6?$AA@NNGAKEGL@
PAGE$s	SEGMENT
??_C@_0BK@HKFOKHIB@Leave?5HandleRemoveDevice?6?$AA@NNGAKEGL@ DB 'Leave Ha'
	DB	'ndleRemoveDevice', 0aH, 00H			;  ?? ::NNGAKEGL::`string'
PAGE$s	ENDS
;	COMDAT ??_C@_0BK@PNHNEGHL@Enter?5HandleRemoveDevice?6?$AA@NNGAKEGL@
PAGE$s	SEGMENT
??_C@_0BK@PNHNEGHL@Enter?5HandleRemoveDevice?6?$AA@NNGAKEGL@ DB 'Enter Ha'
	DB	'ndleRemoveDevice', 0aH, 00H			;  ?? ::NNGAKEGL::`string'
PAGE$s	ENDS
;	COMDAT ??_C@_0BJ@LCDPKFDN@Leave?5DefaultPnpHandler?6?$AA@NNGAKEGL@
PAGE$s	SEGMENT
??_C@_0BJ@LCDPKFDN@Leave?5DefaultPnpHandler?6?$AA@NNGAKEGL@ DB 'Leave Def'
	DB	'aultPnpHandler', 0aH, 00H			;  ?? ::NNGAKEGL::`string'
PAGE$s	ENDS
;	COMDAT ??_C@_0BJ@JJHNINKM@Enter?5DefaultPnpHandler?6?$AA@NNGAKEGL@
PAGE$s	SEGMENT
??_C@_0BJ@JJHNINKM@Enter?5DefaultPnpHandler?6?$AA@NNGAKEGL@ DB 'Enter Def'
	DB	'aultPnpHandler', 0aH, 00H			;  ?? ::NNGAKEGL::`string'
PAGE$s	ENDS
;	COMDAT ??_C@_0BJ@GNFEGBFC@Leave?5HelloWDMAddDevice?6?$AA@NNGAKEGL@
PAGE$s	SEGMENT
??_C@_0BJ@GNFEGBFC@Leave?5HelloWDMAddDevice?6?$AA@NNGAKEGL@ DB 'Leave Hel'
	DB	'loWDMAddDevice', 0aH, 00H			;  ?? ::NNGAKEGL::`string'
PAGE$s	ENDS
;	COMDAT ??_C@_1CK@DCLOCDEE@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AAH?$AAe?$AAl?$AAl?$AAo?$AAW?$AAD?$AAM?$AA?$AA@NNGAKEGL@
PAGE$s	SEGMENT
??_C@_1CK@DCLOCDEE@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AAH?$AAe?$AAl?$AAl?$AAo?$AAW?$AAD?$AAM?$AA?$AA@NNGAKEGL@ DB '\'
	DB	00H, 'D', 00H, 'o', 00H, 's', 00H, 'D', 00H, 'e', 00H, 'v', 00H
	DB	'i', 00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 'H', 00H, 'e'
	DB	00H, 'l', 00H, 'l', 00H, 'o', 00H, 'W', 00H, 'D', 00H, 'M', 00H
	DB	00H, 00H					;  ?? ::NNGAKEGL::`string'
PAGE$s	ENDS
;	COMDAT ??_C@_1CI@GBMGKAIE@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAM?$AAy?$AAW?$AAD?$AAM?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?$AA@NNGAKEGL@
PAGE$s	SEGMENT
??_C@_1CI@GBMGKAIE@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAM?$AAy?$AAW?$AAD?$AAM?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?$AA@NNGAKEGL@ DB '\'
	DB	00H, 'D', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H
	DB	'\', 00H, 'M', 00H, 'y', 00H, 'W', 00H, 'D', 00H, 'M', 00H, 'D'
	DB	00H, 'e', 00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H, 00H, 00H ;  ?? ::NNGAKEGL::`string'
PAGE$s	ENDS
;	COMDAT ??_C@_0BJ@EGBGEJMD@Enter?5HelloWDMAddDevice?6?$AA@NNGAKEGL@
PAGE$s	SEGMENT
??_C@_0BJ@EGBGEJMD@Enter?5HelloWDMAddDevice?6?$AA@NNGAKEGL@ DB 'Enter Hel'
	DB	'loWDMAddDevice', 0aH, 00H			;  ?? ::NNGAKEGL::`string'
PAGE$s	ENDS
;	COMDAT ??_C@_0BD@JKACOMOD@Leave?5DriverEntry?6?$AA@PBOPGDP@
INIT$s	SEGMENT
??_C@_0BD@JKACOMOD@Leave?5DriverEntry?6?$AA@PBOPGDP@ DB 'Leave DriverEntr'
	DB	'y', 0aH, 00H				;  ?? ::PBOPGDP::`string'
INIT$s	ENDS
;	COMDAT ??_C@_0BD@EKOFGNJI@Enter?5DriverEntry?6?$AA@PBOPGDP@
INIT$s	SEGMENT
??_C@_0BD@EKOFGNJI@Enter?5DriverEntry?6?$AA@PBOPGDP@ DB 'Enter DriverEntr'
	DB	'y', 0aH, 00H				;  ?? ::PBOPGDP::`string'
INIT$s	ENDS
;	COMDAT ??_C@_0BN@CEGJCNKD@?$FL?$CFs?$FN?5ExternWorkThread?5Leave?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BN@CEGJCNKD@?$FL?$CFs?$FN?5ExternWorkThread?5Leave?6?$AA@FNODOBFM@ DB '['
	DB	'%s] ExternWorkThread Leave', 0aH, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BP@HECHHJL@?$FL?$CFs?$FN?5ExternWorkThread?5Running?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BP@HECHHJL@?$FL?$CFs?$FN?5ExternWorkThread?5Running?6?$AA@FNODOBFM@ DB '['
	DB	'%s] ExternWorkThread Running', 0aH, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BB@HKPGLIGD@ExternWorkThread?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BB@HKPGLIGD@ExternWorkThread?$AA@FNODOBFM@ DB 'ExternWorkThread', 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CI@FGGEEPLK@?$CK?$CK?5?$FL?$CFs?$FN?5MySleep?5IRQL?5?$DO?5APC_LEVEL@FNODOBFM@
text$s	SEGMENT
??_C@_0CI@FGGEEPLK@?$CK?$CK?5?$FL?$CFs?$FN?5MySleep?5IRQL?5?$DO?5APC_LEVEL@FNODOBFM@ DB '*'
	DB	'* [%s] MySleep IRQL > APC_LEVEL, = %d', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_07OKLGPFEL@MySleep?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_07OKLGPFEL@MySleep?$AA@FNODOBFM@ DB 'MySleep', 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
; Function compile flags: /Odtp
; File c:\users\lw8172\documents\github\hooktestbed\wdmdrivertest\wdmdrivertest\device.cpp
;	COMDAT ?HandleRemoveDevice@@YGJPAU_DEVICE_EXTENSION@@PAU_IRP@@@Z
PAGE	SEGMENT
$T1 = -28						; size = 8
_status$ = -20						; size = 4
tv91 = -16						; size = 4
$T2 = -12						; size = 4
tv70 = -8						; size = 4
$T3 = -4						; size = 4
_pdx$ = 8						; size = 4
_Irp$ = 12						; size = 4
?HandleRemoveDevice@@YGJPAU_DEVICE_EXTENSION@@PAU_IRP@@@Z PROC ; HandleRemoveDevice, COMDAT

; 201  : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 202  : 	PAGED_CODE();

	call	DWORD PTR __imp__KeGetCurrentIrql@0
	movzx	eax, al
	cmp	eax, 1
	jle	SHORT $LN4@HandleRemo
__annotation$8:
	int	44					; 0000002cH
	mov	DWORD PTR tv70[ebp], 0
	jmp	SHORT $LN5@HandleRemo
$LN4@HandleRemo:
	mov	DWORD PTR tv70[ebp], 1
$LN5@HandleRemo:

; 203  : 	KdPrint(("Enter HandleRemoveDevice\n"));

	push	OFFSET ??_C@_0BK@PNHNEGHL@Enter?5HandleRemoveDevice?6?$AA@NNGAKEGL@
	call	_DbgPrint
	add	esp, 4

; 204  : 
; 205  : 	Irp->IoStatus.Status = STATUS_SUCCESS;

	mov	ecx, DWORD PTR _Irp$[ebp]
	mov	DWORD PTR [ecx+24], 0

; 206  : 	NTSTATUS status = DefaultPnpHandler(pdx, Irp);

	mov	edx, DWORD PTR _Irp$[ebp]
	push	edx
	mov	eax, DWORD PTR _pdx$[ebp]
	push	eax
	call	?DefaultPnpHandler@@YGJPAU_DEVICE_EXTENSION@@PAU_IRP@@@Z ; DefaultPnpHandler
	mov	DWORD PTR _status$[ebp], eax

; 207  : 	IoDeleteSymbolicLink(&(UNICODE_STRING)pdx->ustrSymLinkName);

	mov	ecx, DWORD PTR _pdx$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [ecx+20]
	mov	DWORD PTR $T1[ebp], edx
	mov	DWORD PTR $T1[ebp+4], eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	DWORD PTR __imp__IoDeleteSymbolicLink@4

; 208  : 
; 209  :     //调用IoDetachDevice()把fdo从设备栈中脱开：
; 210  :     if (pdx->NextStackDevice)

	mov	edx, DWORD PTR _pdx$[ebp]
	cmp	DWORD PTR [edx+4], 0
	je	SHORT $LN1@HandleRemo

; 211  :         IoDetachDevice(pdx->NextStackDevice);

	mov	eax, DWORD PTR _pdx$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	DWORD PTR __imp__IoDetachDevice@4
$LN1@HandleRemo:

; 212  : 	
; 213  :     //删除fdo：
; 214  :     IoDeleteDevice(pdx->fdo);

	mov	edx, DWORD PTR _pdx$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	DWORD PTR __imp__IoDeleteDevice@4

; 215  : 
; 216  : 	delete pdx->pHelper;

	mov	ecx, DWORD PTR _pdx$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR $T2[ebp], edx
	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR $T3[ebp], eax
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN6@HandleRemo
	push	1
	mov	ecx, DWORD PTR $T3[ebp]
	call	??_GHookHelper@@QAEPAXI@Z
	mov	DWORD PTR tv91[ebp], eax
	jmp	SHORT $LN7@HandleRemo
$LN6@HandleRemo:
	mov	DWORD PTR tv91[ebp], 0
$LN7@HandleRemo:

; 217  : 
; 218  : 	KdPrint(("Leave HandleRemoveDevice\n"));

	push	OFFSET ??_C@_0BK@HKFOKHIB@Leave?5HandleRemoveDevice?6?$AA@NNGAKEGL@
	call	_DbgPrint
	add	esp, 4

; 219  : 	return status;

	mov	eax, DWORD PTR _status$[ebp]

; 220  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?HandleRemoveDevice@@YGJPAU_DEVICE_EXTENSION@@PAU_IRP@@@Z ENDP ; HandleRemoveDevice
PAGE	ENDS
; Function compile flags: /Odtp
; File c:\users\lw8172\documents\github\hooktestbed\wdmdrivertest\wdmdrivertest\device.cpp
;	COMDAT ?DefaultPnpHandler@@YGJPAU_DEVICE_EXTENSION@@PAU_IRP@@@Z
PAGE	SEGMENT
tv70 = -4						; size = 4
_pdx$ = 8						; size = 4
_Irp$ = 12						; size = 4
?DefaultPnpHandler@@YGJPAU_DEVICE_EXTENSION@@PAU_IRP@@@Z PROC ; DefaultPnpHandler, COMDAT

; 183  : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 184  : 	PAGED_CODE();

	call	DWORD PTR __imp__KeGetCurrentIrql@0
	movzx	eax, al
	cmp	eax, 1
	jle	SHORT $LN3@DefaultPnp
__annotation$5:
	int	44					; 0000002cH
	mov	DWORD PTR tv70[ebp], 0
	jmp	SHORT $LN4@DefaultPnp
$LN3@DefaultPnp:
	mov	DWORD PTR tv70[ebp], 1
$LN4@DefaultPnp:

; 185  : 	KdPrint(("Enter DefaultPnpHandler\n"));

	push	OFFSET ??_C@_0BJ@JJHNINKM@Enter?5DefaultPnpHandler?6?$AA@NNGAKEGL@
	call	_DbgPrint
	add	esp, 4

; 186  : 	IoSkipCurrentIrpStackLocation(Irp);

	mov	ecx, DWORD PTR _Irp$[ebp]
	push	ecx
	call	_IoSkipCurrentIrpStackLocation@4

; 187  : 	KdPrint(("Leave DefaultPnpHandler\n"));

	push	OFFSET ??_C@_0BJ@LCDPKFDN@Leave?5DefaultPnpHandler?6?$AA@NNGAKEGL@
	call	_DbgPrint
	add	esp, 4

; 188  : 	return IoCallDriver(pdx->NextStackDevice, Irp);

	mov	edx, DWORD PTR _Irp$[ebp]
	mov	eax, DWORD PTR _pdx$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	DWORD PTR __imp_@IofCallDriver@8

; 189  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?DefaultPnpHandler@@YGJPAU_DEVICE_EXTENSION@@PAU_IRP@@@Z ENDP ; DefaultPnpHandler
PAGE	ENDS
; Function compile flags: /Odtp
; File c:\users\lw8172\documents\github\hooktestbed\wdmdrivertest\wdmdrivertest\device.cpp
;	COMDAT _ExternWorkThread@4
_TEXT	SEGMENT
_pdx$ = -16						; size = 4
_pHelper$ = -12						; size = 4
tv72 = -8						; size = 4
$T1 = -4						; size = 4
_pContext$ = 8						; size = 4
_ExternWorkThread@4 PROC				; COMDAT

; 61   : {  

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 62   : 	PDEVICE_EXTENSION pdx = (PDEVICE_EXTENSION) pContext;

	mov	eax, DWORD PTR _pContext$[ebp]
	mov	DWORD PTR _pdx$[ebp], eax

; 63   : 	KdPrint(("[%s] ExternWorkThread Running\n", __FUNCTION__)); 

	push	OFFSET ??_C@_0BB@HKPGLIGD@ExternWorkThread?$AA@FNODOBFM@
	push	OFFSET ??_C@_0BP@HECHHJL@?$FL?$CFs?$FN?5ExternWorkThread?5Running?6?$AA@FNODOBFM@
	call	_DbgPrint
	add	esp, 8

; 64   : 	ULONG uAddress;
; 65   : 
; 66   : 	HookHelper *pHelper = new (NonPagedPool) HookHelper();

	push	0
	push	2
	call	??2@YAPAXIW4_POOL_TYPE@@@Z		; operator new
	add	esp, 8
	mov	DWORD PTR $T1[ebp], eax
	cmp	DWORD PTR $T1[ebp], 0
	je	SHORT $LN3@ExternWork
	mov	ecx, DWORD PTR $T1[ebp]
	call	??0HookHelper@@QAE@XZ			; HookHelper::HookHelper
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN4@ExternWork
$LN3@ExternWork:
	mov	DWORD PTR tv72[ebp], 0
$LN4@ExternWork:
	mov	ecx, DWORD PTR tv72[ebp]
	mov	DWORD PTR _pHelper$[ebp], ecx

; 67   : 	//pHelper->HookObReferenceObjectByHandle(NULL);
; 68   : 	//pHelper->HookNtCreateProcess(NULL);
; 69   : 
; 70   : 	//00005db8 24548d00 086a9c04 002145e8 ZwCreateUserProcess
; 71   : 	pHelper->HookNtCreateProcess(NULL);

	push	0
	mov	ecx, DWORD PTR _pHelper$[ebp]
	call	?HookNtCreateProcess@HookHelper@@QAEEPAPAX@Z ; HookHelper::HookNtCreateProcess

; 72   : 
; 73   : 	pdx->pHelper = pHelper;

	mov	edx, DWORD PTR _pdx$[ebp]
	mov	eax, DWORD PTR _pHelper$[ebp]
	mov	DWORD PTR [edx+28], eax

; 74   : 
; 75   : 	MySleep(1000);

	push	1000					; 000003e8H
	call	_MySleep@4

; 76   : 
; 77   : 
; 78   : 	KdPrint(("[%s] ExternWorkThread Leave\n", __FUNCTION__));  

	push	OFFSET ??_C@_0BB@HKPGLIGD@ExternWorkThread?$AA@FNODOBFM@
	push	OFFSET ??_C@_0BN@CEGJCNKD@?$FL?$CFs?$FN?5ExternWorkThread?5Leave?6?$AA@FNODOBFM@
	call	_DbgPrint
	add	esp, 8

; 79   : 	PsTerminateSystemThread(STATUS_SUCCESS);  

	push	0
	call	DWORD PTR __imp__PsTerminateSystemThread@4

; 80   : }  

	mov	esp, ebp
	pop	ebp
	ret	4
_ExternWorkThread@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\lw8172\documents\github\hooktestbed\wdmdrivertest\wdmdrivertest\device.cpp
;	COMDAT _MySleep@4
_TEXT	SEGMENT
tv163 = -44						; size = 8
_startTime$1 = -36					; size = 8
_currentTime$2 = -28					; size = 8
_liTime$3 = -20						; size = 8
_my_interval$4 = -12					; size = 8
_irql$ = -1						; size = 1
_msec$ = 8						; size = 4
_MySleep@4 PROC						; COMDAT

; 20   : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH

; 21   : 	KIRQL irql = KeGetCurrentIrql();

	call	DWORD PTR __imp__KeGetCurrentIrql@0
	mov	BYTE PTR _irql$[ebp], al

; 22   : 	if( irql <= APC_LEVEL )

	movzx	eax, BYTE PTR _irql$[ebp]
	cmp	eax, 1
	jg	SHORT $LN5@MySleep

; 23   : 	{
; 24   : 		LARGE_INTEGER my_interval; 
; 25   : 		my_interval.QuadPart = DELAY_ONE_MILLISECOND; 

	mov	DWORD PTR _my_interval$4[ebp], -10000	; ffffd8f0H
	mov	DWORD PTR _my_interval$4[ebp+4], -1

; 26   : 		my_interval.QuadPart *= msec; 

	mov	eax, DWORD PTR _msec$[ebp]
	cdq
	push	edx
	push	eax
	mov	ecx, DWORD PTR _my_interval$4[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _my_interval$4[ebp]
	push	edx
	call	__allmul
	mov	DWORD PTR _my_interval$4[ebp], eax
	mov	DWORD PTR _my_interval$4[ebp+4], edx

; 27   : 		KeDelayExecutionThread(KernelMode,FALSE,&my_interval); 

	lea	eax, DWORD PTR _my_interval$4[ebp]
	push	eax
	push	0
	push	0
	call	DWORD PTR __imp__KeDelayExecutionThread@12

; 28   : 	}
; 29   : 	else

	jmp	$LN6@MySleep
$LN5@MySleep:

; 30   : 	{
; 31   : 		KdPrint(("** [%s] MySleep IRQL > APC_LEVEL, = %d\n", __FUNCTION__, irql));

	movzx	ecx, BYTE PTR _irql$[ebp]
	push	ecx
	push	OFFSET ??_C@_07OKLGPFEL@MySleep?$AA@FNODOBFM@
	push	OFFSET ??_C@_0CI@FGGEEPLK@?$CK?$CK?5?$FL?$CFs?$FN?5MySleep?5IRQL?5?$DO?5APC_LEVEL@FNODOBFM@
	call	_DbgPrint
	add	esp, 12					; 0000000cH

; 32   : 		LARGE_INTEGER liTime = {0}, startTime = {0}, currentTime = {0};

	mov	DWORD PTR _liTime$3[ebp], 0
	xor	edx, edx
	mov	DWORD PTR _liTime$3[ebp+4], edx
	mov	DWORD PTR _startTime$1[ebp], 0
	xor	eax, eax
	mov	DWORD PTR _startTime$1[ebp+4], eax
	mov	DWORD PTR _currentTime$2[ebp], 0
	xor	ecx, ecx
	mov	DWORD PTR _currentTime$2[ebp+4], ecx

; 33   : 
; 34   : 
; 35   : 		/* Convert milliseconds to 100-nanosecond increments using:
; 36   : 		 *
; 37   : 		 *     1 ns = 10 ^ -9 sec
; 38   : 		 *   100 ns = 10 ^ -7 sec (1 timer interval)
; 39   : 		 *     1 ms = 10 ^ -3 sec
; 40   : 		 *     1 ms = (1 timer interval) * 10^4
; 41   : 		 */
; 42   : 		msec = msec * 10000;

	mov	edx, DWORD PTR _msec$[ebp]
	imul	edx, 10000				; 00002710H
	mov	DWORD PTR _msec$[ebp], edx

; 43   :             
; 44   : 		KeQuerySystemTime(&startTime);

	lea	eax, DWORD PTR _startTime$1[ebp]
	push	eax
	call	DWORD PTR __imp__KeQuerySystemTime@4
$LN3@MySleep:

; 45   : 		while(1)

	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN6@MySleep

; 46   : 		{
; 47   : 		   KeQuerySystemTime(&currentTime);

	lea	edx, DWORD PTR _currentTime$2[ebp]
	push	edx
	call	DWORD PTR __imp__KeQuerySystemTime@4

; 48   : 		   liTime.QuadPart = currentTime.QuadPart - startTime.QuadPart;

	mov	eax, DWORD PTR _currentTime$2[ebp]
	sub	eax, DWORD PTR _startTime$1[ebp]
	mov	ecx, DWORD PTR _currentTime$2[ebp+4]
	sbb	ecx, DWORD PTR _startTime$1[ebp+4]
	mov	DWORD PTR _liTime$3[ebp], eax
	mov	DWORD PTR _liTime$3[ebp+4], ecx

; 49   : 		   if(liTime.QuadPart >= msec) 

	mov	eax, DWORD PTR _msec$[ebp]
	cdq
	mov	DWORD PTR tv163[ebp], eax
	mov	DWORD PTR tv163[ebp+4], edx
	mov	edx, DWORD PTR _liTime$3[ebp+4]
	cmp	edx, DWORD PTR tv163[ebp+4]
	jl	SHORT $LN1@MySleep
	jg	SHORT $LN8@MySleep
	mov	eax, DWORD PTR _liTime$3[ebp]
	cmp	eax, DWORD PTR tv163[ebp]
	jb	SHORT $LN1@MySleep
$LN8@MySleep:

; 50   : 			   break;

	jmp	SHORT $LN6@MySleep
$LN1@MySleep:

; 51   : 		}

	jmp	SHORT $LN3@MySleep
$LN6@MySleep:

; 52   : 	}
; 53   : }

	mov	esp, ebp
	pop	ebp
	ret	4
_MySleep@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\lw8172\documents\github\hooktestbed\wdmdrivertest\wdmdrivertest\utils.h
;	COMDAT ??2@YAPAXIW4_POOL_TYPE@@@Z
_TEXT	SEGMENT
_size$ = 8						; size = 4
_pagePool$ = 12						; size = 4
??2@YAPAXIW4_POOL_TYPE@@@Z PROC				; operator new, COMDAT

; 21   : {

	npad	2
	push	ebp
	mov	ebp, esp

; 22   : 	return ExAllocatePool(pagePool, size);

	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pagePool$[ebp]
	push	ecx
	call	DWORD PTR __imp__ExAllocatePool@8

; 23   : }

	pop	ebp
	ret	0
??2@YAPAXIW4_POOL_TYPE@@@Z ENDP				; operator new
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GHookHelper@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GHookHelper@@QAEPAXI@Z PROC				; HookHelper::`scalar deleting destructor', COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1HookHelper@@QAE@XZ			; HookHelper::~HookHelper
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GHookHelper@@QAEPAXI@Z ENDP				; HookHelper::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\lw8172\documents\github\hooktestbed\wdmdrivertest\wdmdrivertest\device.cpp
;	COMDAT _DriverEntry@8
INIT	SEGMENT
_pDriverObject$ = 8					; size = 4
_pRegistryPath$ = 12					; size = 4
_DriverEntry@8 PROC					; COMDAT

; 93   : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi

; 94   : 	KdPrint(("Enter DriverEntry\n"));

	push	OFFSET ??_C@_0BD@EKOFGNJI@Enter?5DriverEntry?6?$AA@PBOPGDP@
	call	_DbgPrint
	add	esp, 4

; 95   : 
; 96   : 	pDriverObject->DriverExtension->AddDevice = HelloWDMAddDevice;

	mov	eax, DWORD PTR _pDriverObject$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR [ecx+4], OFFSET ?HelloWDMAddDevice@@YGJPAU_DRIVER_OBJECT@@PAU_DEVICE_OBJECT@@@Z ; HelloWDMAddDevice

; 97   : 	pDriverObject->MajorFunction[IRP_MJ_PNP] = HelloWDMPnp;

	mov	edx, 4
	imul	edx, 27					; 0000001bH
	mov	eax, DWORD PTR _pDriverObject$[ebp]
	mov	DWORD PTR [eax+edx+56], OFFSET ?HelloWDMPnp@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@@Z ; HelloWDMPnp

; 98   : 	pDriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = 
; 99   : 	pDriverObject->MajorFunction[IRP_MJ_CREATE] = 
; 100  : 	pDriverObject->MajorFunction[IRP_MJ_READ] = 
; 101  : 	pDriverObject->MajorFunction[IRP_MJ_WRITE] = HelloWDMDispatchRoutine;

	mov	ecx, 4
	shl	ecx, 2
	mov	edx, DWORD PTR _pDriverObject$[ebp]
	mov	DWORD PTR [edx+ecx+56], OFFSET ?HelloWDMDispatchRoutine@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@@Z ; HelloWDMDispatchRoutine
	mov	eax, 4
	shl	eax, 2
	mov	ecx, 4
	imul	ecx, 3
	mov	edx, DWORD PTR _pDriverObject$[ebp]
	mov	esi, DWORD PTR _pDriverObject$[ebp]
	mov	eax, DWORD PTR [esi+eax+56]
	mov	DWORD PTR [edx+ecx+56], eax
	mov	ecx, 4
	imul	ecx, 3
	mov	edx, 4
	imul	edx, 0
	mov	eax, DWORD PTR _pDriverObject$[ebp]
	mov	esi, DWORD PTR _pDriverObject$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+56]
	mov	DWORD PTR [eax+edx+56], ecx
	mov	edx, 4
	imul	edx, 0
	mov	eax, 4
	imul	eax, 14					; 0000000eH
	mov	ecx, DWORD PTR _pDriverObject$[ebp]
	mov	esi, DWORD PTR _pDriverObject$[ebp]
	mov	edx, DWORD PTR [esi+edx+56]
	mov	DWORD PTR [ecx+eax+56], edx

; 102  : 	pDriverObject->DriverUnload = HelloWDMUnload;

	mov	eax, DWORD PTR _pDriverObject$[ebp]
	mov	DWORD PTR [eax+52], OFFSET ?HelloWDMUnload@@YGXPAU_DRIVER_OBJECT@@@Z ; HelloWDMUnload

; 103  : 
; 104  : 	KdPrint(("Leave DriverEntry\n"));

	push	OFFSET ??_C@_0BD@JKACOMOD@Leave?5DriverEntry?6?$AA@PBOPGDP@
	call	_DbgPrint
	add	esp, 4

; 105  : 	return STATUS_SUCCESS;

	xor	eax, eax

; 106  : }

	pop	esi
	pop	ebp
	ret	8
_DriverEntry@8 ENDP
INIT	ENDS
; Function compile flags: /Odtp
; File c:\users\lw8172\documents\github\hooktestbed\wdmdrivertest\wdmdrivertest\device.cpp
;	COMDAT ?HelloWDMUnload@@YGXPAU_DRIVER_OBJECT@@@Z
PAGE	SEGMENT
tv70 = -4						; size = 4
_DriverObject$ = 8					; size = 4
?HelloWDMUnload@@YGXPAU_DRIVER_OBJECT@@@Z PROC		; HelloWDMUnload, COMDAT

; 347  : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 348  : 	PAGED_CODE();

	call	DWORD PTR __imp__KeGetCurrentIrql@0
	movzx	eax, al
	cmp	eax, 1
	jle	SHORT $LN3@HelloWDMUn
__annotation$5:
	int	44					; 0000002cH
	mov	DWORD PTR tv70[ebp], 0
	jmp	SHORT $LN4@HelloWDMUn
$LN3@HelloWDMUn:
	mov	DWORD PTR tv70[ebp], 1
$LN4@HelloWDMUn:

; 349  : 	KdPrint(("Enter HelloWDMUnload\n"));

	push	OFFSET ??_C@_0BG@GJALPNMI@Enter?5HelloWDMUnload?6?$AA@NNGAKEGL@
	call	_DbgPrint
	add	esp, 4

; 350  : 	KdPrint(("Leave HelloWDMUnload\n"));

	push	OFFSET ??_C@_0BG@CNFJKEHI@Leave?5HelloWDMUnload?6?$AA@NNGAKEGL@
	call	_DbgPrint
	add	esp, 4

; 351  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?HelloWDMUnload@@YGXPAU_DRIVER_OBJECT@@@Z ENDP		; HelloWDMUnload
PAGE	ENDS
; Function compile flags: /Odtp
; File c:\users\lw8172\documents\github\hooktestbed\wdmdrivertest\wdmdrivertest\device.cpp
;	COMDAT ?HelloWDMDispatchRoutine@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@@Z
PAGE	SEGMENT
tv70 = -4						; size = 4
_fdo$ = 8						; size = 4
_Irp$ = 12						; size = 4
?HelloWDMDispatchRoutine@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@@Z PROC ; HelloWDMDispatchRoutine, COMDAT

; 328  : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 329  : 	PAGED_CODE();

	call	DWORD PTR __imp__KeGetCurrentIrql@0
	movzx	eax, al
	cmp	eax, 1
	jle	SHORT $LN3@HelloWDMDi
__annotation$5:
	int	44					; 0000002cH
	mov	DWORD PTR tv70[ebp], 0
	jmp	SHORT $LN4@HelloWDMDi
$LN3@HelloWDMDi:
	mov	DWORD PTR tv70[ebp], 1
$LN4@HelloWDMDi:

; 330  : 	KdPrint(("Enter HelloWDMDispatchRoutine\n"));

	push	OFFSET ??_C@_0BP@GCFKMKJE@Enter?5HelloWDMDispatchRoutine?6?$AA@NNGAKEGL@
	call	_DbgPrint
	add	esp, 4

; 331  : 	Irp->IoStatus.Status = STATUS_SUCCESS;

	mov	ecx, DWORD PTR _Irp$[ebp]
	mov	DWORD PTR [ecx+24], 0

; 332  : 	Irp->IoStatus.Information = 0;	// no bytes xfered

	mov	edx, DWORD PTR _Irp$[ebp]
	mov	DWORD PTR [edx+28], 0

; 333  : 	IoCompleteRequest( Irp, IO_NO_INCREMENT );

	xor	dl, dl
	mov	ecx, DWORD PTR _Irp$[ebp]
	call	DWORD PTR __imp_@IofCompleteRequest@8

; 334  : 	KdPrint(("Leave HelloWDMDispatchRoutine\n"));

	push	OFFSET ??_C@_0BP@EANEFCAA@Leave?5HelloWDMDispatchRoutine?6?$AA@NNGAKEGL@
	call	_DbgPrint
	add	esp, 4

; 335  : 	return STATUS_SUCCESS;

	xor	eax, eax

; 336  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?HelloWDMDispatchRoutine@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@@Z ENDP ; HelloWDMDispatchRoutine
PAGE	ENDS
; Function compile flags: /Odtp
; File c:\users\lw8172\documents\github\hooktestbed\wdmdrivertest\wdmdrivertest\device.cpp
;	COMDAT ?HelloWDMPnp@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@@Z
PAGE	SEGMENT
_stack$ = -28						; size = 4
_pStrProcessName$ = -24					; size = 4
_curProcess$ = -20					; size = 4
tv70 = -16						; size = 4
_pdx$ = -12						; size = 4
_fcn$ = -8						; size = 4
_status$ = -4						; size = 4
_fdo$ = 8						; size = 4
_Irp$ = 12						; size = 4
?HelloWDMPnp@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@@Z PROC	; HelloWDMPnp, COMDAT

; 233  : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 234  : 	PAGED_CODE();

	call	DWORD PTR __imp__KeGetCurrentIrql@0
	movzx	eax, al
	cmp	eax, 1
	jle	SHORT $LN4@HelloWDMPn
__annotation$6:
	int	44					; 0000002cH
	mov	DWORD PTR tv70[ebp], 0
	jmp	SHORT $LN5@HelloWDMPn
$LN4@HelloWDMPn:
	mov	DWORD PTR tv70[ebp], 1
$LN5@HelloWDMPn:

; 235  : 
; 236  : 	KdPrint(("Enter HelloWDMPnp\n"));

	push	OFFSET ??_C@_0BD@MLKMKNJP@Enter?5HelloWDMPnp?6?$AA@NNGAKEGL@
	call	_DbgPrint
	add	esp, 4

; 237  : 	PEPROCESS curProcess = PsGetCurrentProcess();

	call	DWORD PTR __imp__IoGetCurrentProcess@0
	mov	DWORD PTR _curProcess$[ebp], eax

; 238  : 	NTSTATUS status = STATUS_SUCCESS;

	mov	DWORD PTR _status$[ebp], 0

; 239  : 	PDEVICE_EXTENSION pdx = (PDEVICE_EXTENSION) fdo->DeviceExtension;

	mov	ecx, DWORD PTR _fdo$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR _pdx$[ebp], edx

; 240  : 	PIO_STACK_LOCATION stack = IoGetCurrentIrpStackLocation(Irp);

	mov	eax, DWORD PTR _Irp$[ebp]
	push	eax
	call	_IoGetCurrentIrpStackLocation@4
	mov	DWORD PTR _stack$[ebp], eax

; 241  : 
; 242  : 	PTSTR pStrProcessName = (PTSTR) ((ULONG)curProcess + EPROCESS_NAME_OFFSET);

	mov	ecx, DWORD PTR _curProcess$[ebp]
	add	ecx, 364				; 0000016cH
	mov	DWORD PTR _pStrProcessName$[ebp], ecx

; 243  : 	KdPrint(("CurProcessName: %s\n",pStrProcessName));

	mov	edx, DWORD PTR _pStrProcessName$[ebp]
	push	edx
	push	OFFSET ??_C@_0BE@DFAPAMLB@CurProcessName?3?5?$CFs?6?$AA@NNGAKEGL@
	call	_DbgPrint
	add	esp, 8

; 244  : 
; 245  : 	static NTSTATUS (*fcntab[])(PDEVICE_EXTENSION pdx, PIRP Irp) = 
; 246  : 	{
; 247  : 		DefaultPnpHandler,		// IRP_MN_START_DEVICE
; 248  : 		DefaultPnpHandler,		// IRP_MN_QUERY_REMOVE_DEVICE
; 249  : 		HandleRemoveDevice,		// IRP_MN_REMOVE_DEVICE
; 250  : 		DefaultPnpHandler,		// IRP_MN_CANCEL_REMOVE_DEVICE
; 251  : 		DefaultPnpHandler,		// IRP_MN_STOP_DEVICE
; 252  : 		DefaultPnpHandler,		// IRP_MN_QUERY_STOP_DEVICE
; 253  : 		DefaultPnpHandler,		// IRP_MN_CANCEL_STOP_DEVICE
; 254  : 		DefaultPnpHandler,		// IRP_MN_QUERY_DEVICE_RELATIONS
; 255  : 		DefaultPnpHandler,		// IRP_MN_QUERY_INTERFACE
; 256  : 		DefaultPnpHandler,		// IRP_MN_QUERY_CAPABILITIES
; 257  : 		DefaultPnpHandler,		// IRP_MN_QUERY_RESOURCES
; 258  : 		DefaultPnpHandler,		// IRP_MN_QUERY_RESOURCE_REQUIREMENTS
; 259  : 		DefaultPnpHandler,		// IRP_MN_QUERY_DEVICE_TEXT
; 260  : 		DefaultPnpHandler,		// IRP_MN_FILTER_RESOURCE_REQUIREMENTS
; 261  : 		DefaultPnpHandler,		// 
; 262  : 		DefaultPnpHandler,		// IRP_MN_READ_CONFIG
; 263  : 		DefaultPnpHandler,		// IRP_MN_WRITE_CONFIG
; 264  : 		DefaultPnpHandler,		// IRP_MN_EJECT
; 265  : 		DefaultPnpHandler,		// IRP_MN_SET_LOCK
; 266  : 		DefaultPnpHandler,		// IRP_MN_QUERY_ID
; 267  : 		DefaultPnpHandler,		// IRP_MN_QUERY_PNP_DEVICE_STATE
; 268  : 		DefaultPnpHandler,		// IRP_MN_QUERY_BUS_INFORMATION
; 269  : 		DefaultPnpHandler,		// IRP_MN_DEVICE_USAGE_NOTIFICATION
; 270  : 		DefaultPnpHandler,		// IRP_MN_SURPRISE_REMOVAL
; 271  : 	};
; 272  : 
; 273  : 	ULONG fcn = stack->MinorFunction;

	mov	eax, DWORD PTR _stack$[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	mov	DWORD PTR _fcn$[ebp], ecx

; 274  : 	if (fcn >= arraysize(fcntab))

	cmp	DWORD PTR _fcn$[ebp], 24		; 00000018H
	jb	SHORT $LN1@HelloWDMPn

; 275  : 	{						// unknown function
; 276  : 		status = DefaultPnpHandler(pdx, Irp); // some function we don't know about

	mov	edx, DWORD PTR _Irp$[ebp]
	push	edx
	mov	eax, DWORD PTR _pdx$[ebp]
	push	eax
	call	?DefaultPnpHandler@@YGJPAU_DEVICE_EXTENSION@@PAU_IRP@@@Z ; DefaultPnpHandler
	mov	DWORD PTR _status$[ebp], eax

; 277  : 		return status;

	mov	eax, DWORD PTR _status$[ebp]
	jmp	SHORT $LN2@HelloWDMPn
$LN1@HelloWDMPn:

; 278  : 	}						// unknown function
; 279  : 
; 280  : #if DBG
; 281  : 	static char* fcnname[] = 
; 282  : 	{
; 283  : 		"IRP_MN_START_DEVICE",
; 284  : 		"IRP_MN_QUERY_REMOVE_DEVICE",
; 285  : 		"IRP_MN_REMOVE_DEVICE",
; 286  : 		"IRP_MN_CANCEL_REMOVE_DEVICE",
; 287  : 		"IRP_MN_STOP_DEVICE",
; 288  : 		"IRP_MN_QUERY_STOP_DEVICE",
; 289  : 		"IRP_MN_CANCEL_STOP_DEVICE",
; 290  : 		"IRP_MN_QUERY_DEVICE_RELATIONS",
; 291  : 		"IRP_MN_QUERY_INTERFACE",
; 292  : 		"IRP_MN_QUERY_CAPABILITIES",
; 293  : 		"IRP_MN_QUERY_RESOURCES",
; 294  : 		"IRP_MN_QUERY_RESOURCE_REQUIREMENTS",
; 295  : 		"IRP_MN_QUERY_DEVICE_TEXT",
; 296  : 		"IRP_MN_FILTER_RESOURCE_REQUIREMENTS",
; 297  : 		"",
; 298  : 		"IRP_MN_READ_CONFIG",
; 299  : 		"IRP_MN_WRITE_CONFIG",
; 300  : 		"IRP_MN_EJECT",
; 301  : 		"IRP_MN_SET_LOCK",
; 302  : 		"IRP_MN_QUERY_ID",
; 303  : 		"IRP_MN_QUERY_PNP_DEVICE_STATE",
; 304  : 		"IRP_MN_QUERY_BUS_INFORMATION",
; 305  : 		"IRP_MN_DEVICE_USAGE_NOTIFICATION",
; 306  : 		"IRP_MN_SURPRISE_REMOVAL",
; 307  : 	};
; 308  : 
; 309  : 	KdPrint(("PNP Request (%s)\n", fcnname[fcn]));

	mov	ecx, DWORD PTR _fcn$[ebp]
	mov	edx, DWORD PTR ?fcnname@?4??HelloWDMPnp@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@@Z@4PAPADA[ecx*4]
	push	edx
	push	OFFSET ??_C@_0BC@PKHHAJGP@PNP?5Request?5?$CI?$CFs?$CJ?6?$AA@NNGAKEGL@
	call	_DbgPrint
	add	esp, 8

; 310  : #endif // DBG
; 311  : 
; 312  : 	status = (*fcntab[fcn])(pdx, Irp);

	mov	eax, DWORD PTR _Irp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pdx$[ebp]
	push	ecx
	mov	edx, DWORD PTR _fcn$[ebp]
	mov	eax, DWORD PTR ?fcntab@?1??HelloWDMPnp@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@@Z@4PAP6GJPAU_DEVICE_EXTENSION@@1@ZA[edx*4]
	call	eax
	mov	DWORD PTR _status$[ebp], eax

; 313  : 	KdPrint(("Leave HelloWDMPnp\n"));

	push	OFFSET ??_C@_0BD@BLELCMOE@Leave?5HelloWDMPnp?6?$AA@NNGAKEGL@
	call	_DbgPrint
	add	esp, 4

; 314  : 	return status;

	mov	eax, DWORD PTR _status$[ebp]
$LN2@HelloWDMPn:

; 315  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?HelloWDMPnp@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@@Z ENDP	; HelloWDMPnp
PAGE	ENDS
; Function compile flags: /Odtp
; File c:\users\lw8172\documents\github\hooktestbed\wdmdrivertest\wdmdrivertest\device.cpp
;	COMDAT ?HelloWDMAddDevice@@YGJPAU_DRIVER_OBJECT@@PAU_DEVICE_OBJECT@@@Z
PAGE	SEGMENT
$T1 = -56						; size = 8
$T2 = -48						; size = 8
$T3 = -40						; size = 8
_symLinkName$ = -32					; size = 8
_devName$ = -24						; size = 8
tv70 = -16						; size = 4
_pdx$ = -12						; size = 4
_fdo$ = -8						; size = 4
_status$ = -4						; size = 4
_DriverObject$ = 8					; size = 4
_PhysicalDeviceObject$ = 12				; size = 4
?HelloWDMAddDevice@@YGJPAU_DRIVER_OBJECT@@PAU_DEVICE_OBJECT@@@Z PROC ; HelloWDMAddDevice, COMDAT

; 119  : { 

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H

; 120  : 	PAGED_CODE();

	call	DWORD PTR __imp__KeGetCurrentIrql@0
	movzx	eax, al
	cmp	eax, 1
	jle	SHORT $LN6@HelloWDMAd
__annotation$8:
	int	44					; 0000002cH
	mov	DWORD PTR tv70[ebp], 0
	jmp	SHORT $LN7@HelloWDMAd
$LN6@HelloWDMAd:
	mov	DWORD PTR tv70[ebp], 1
$LN7@HelloWDMAd:

; 121  : 	KdPrint(("Enter HelloWDMAddDevice\n"));

	push	OFFSET ??_C@_0BJ@EGBGEJMD@Enter?5HelloWDMAddDevice?6?$AA@NNGAKEGL@
	call	_DbgPrint
	add	esp, 4

; 122  : 
; 123  : 	NTSTATUS status;
; 124  : 	PDEVICE_OBJECT fdo;
; 125  : 	UNICODE_STRING devName;
; 126  : 	RtlInitUnicodeString(&devName,L"\\Device\\MyWDMDevice");

	push	OFFSET ??_C@_1CI@GBMGKAIE@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAM?$AAy?$AAW?$AAD?$AAM?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?$AA@NNGAKEGL@
	lea	ecx, DWORD PTR _devName$[ebp]
	push	ecx
	call	DWORD PTR __imp__RtlInitUnicodeString@8

; 127  : 	status = IoCreateDevice(
; 128  : 		DriverObject,
; 129  : 		sizeof(DEVICE_EXTENSION),
; 130  : 		&(UNICODE_STRING)devName,
; 131  : 		FILE_DEVICE_UNKNOWN,
; 132  : 		0,
; 133  : 		FALSE,
; 134  : 		&fdo);

	mov	edx, DWORD PTR _devName$[ebp]
	mov	DWORD PTR $T3[ebp], edx
	mov	eax, DWORD PTR _devName$[ebp+4]
	mov	DWORD PTR $T3[ebp+4], eax
	lea	ecx, DWORD PTR _fdo$[ebp]
	push	ecx
	push	0
	push	0
	push	34					; 00000022H
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	push	32					; 00000020H
	mov	eax, DWORD PTR _DriverObject$[ebp]
	push	eax
	call	DWORD PTR __imp__IoCreateDevice@28
	mov	DWORD PTR _status$[ebp], eax

; 135  : 	if( !NT_SUCCESS(status))

	cmp	DWORD PTR _status$[ebp], 0
	jge	SHORT $LN3@HelloWDMAd

; 136  : 		return status;

	mov	eax, DWORD PTR _status$[ebp]
	jmp	$LN4@HelloWDMAd
$LN3@HelloWDMAd:

; 137  : 	PDEVICE_EXTENSION pdx = (PDEVICE_EXTENSION)fdo->DeviceExtension;

	mov	ecx, DWORD PTR _fdo$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR _pdx$[ebp], edx

; 138  : 	pdx->fdo = fdo;

	mov	eax, DWORD PTR _pdx$[ebp]
	mov	ecx, DWORD PTR _fdo$[ebp]
	mov	DWORD PTR [eax], ecx

; 139  : 	pdx->NextStackDevice = IoAttachDeviceToDeviceStack(fdo, PhysicalDeviceObject);

	mov	edx, DWORD PTR _PhysicalDeviceObject$[ebp]
	push	edx
	mov	eax, DWORD PTR _fdo$[ebp]
	push	eax
	call	DWORD PTR __imp__IoAttachDeviceToDeviceStack@8
	mov	ecx, DWORD PTR _pdx$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 140  : 	UNICODE_STRING symLinkName;
; 141  : 	RtlInitUnicodeString(&symLinkName,L"\\DosDevices\\HelloWDM");

	push	OFFSET ??_C@_1CK@DCLOCDEE@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AAH?$AAe?$AAl?$AAl?$AAo?$AAW?$AAD?$AAM?$AA?$AA@NNGAKEGL@
	lea	edx, DWORD PTR _symLinkName$[ebp]
	push	edx
	call	DWORD PTR __imp__RtlInitUnicodeString@8

; 142  : 
; 143  : 	pdx->ustrDeviceName = devName;

	mov	eax, DWORD PTR _pdx$[ebp]
	mov	ecx, DWORD PTR _devName$[ebp]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _devName$[ebp+4]
	mov	DWORD PTR [eax+12], edx

; 144  : 	pdx->ustrSymLinkName = symLinkName;

	mov	eax, DWORD PTR _pdx$[ebp]
	mov	ecx, DWORD PTR _symLinkName$[ebp]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR _symLinkName$[ebp+4]
	mov	DWORD PTR [eax+20], edx

; 145  : 	status = IoCreateSymbolicLink(&(UNICODE_STRING)symLinkName,&(UNICODE_STRING)devName);

	mov	eax, DWORD PTR _devName$[ebp]
	mov	DWORD PTR $T2[ebp], eax
	mov	ecx, DWORD PTR _devName$[ebp+4]
	mov	DWORD PTR $T2[ebp+4], ecx
	mov	edx, DWORD PTR _symLinkName$[ebp]
	mov	DWORD PTR $T1[ebp], edx
	mov	eax, DWORD PTR _symLinkName$[ebp+4]
	mov	DWORD PTR $T1[ebp+4], eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	call	DWORD PTR __imp__IoCreateSymbolicLink@8
	mov	DWORD PTR _status$[ebp], eax

; 146  : 
; 147  : 	if( !NT_SUCCESS(status))

	cmp	DWORD PTR _status$[ebp], 0
	jge	SHORT $LN2@HelloWDMAd

; 148  : 	{
; 149  : 		IoDeleteSymbolicLink(&pdx->ustrSymLinkName);

	mov	eax, DWORD PTR _pdx$[ebp]
	add	eax, 16					; 00000010H
	push	eax
	call	DWORD PTR __imp__IoDeleteSymbolicLink@4

; 150  : 		status = IoCreateSymbolicLink(&symLinkName,&devName);

	lea	ecx, DWORD PTR _devName$[ebp]
	push	ecx
	lea	edx, DWORD PTR _symLinkName$[ebp]
	push	edx
	call	DWORD PTR __imp__IoCreateSymbolicLink@8
	mov	DWORD PTR _status$[ebp], eax

; 151  : 		if( !NT_SUCCESS(status))

	cmp	DWORD PTR _status$[ebp], 0
	jge	SHORT $LN2@HelloWDMAd

; 152  : 		{
; 153  : 			return status;

	mov	eax, DWORD PTR _status$[ebp]
	jmp	SHORT $LN4@HelloWDMAd
$LN2@HelloWDMAd:

; 154  : 		}
; 155  : 	}
; 156  : 
; 157  : 	fdo->Flags |= DO_BUFFERED_IO | DO_POWER_PAGABLE;

	mov	eax, DWORD PTR _fdo$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	or	ecx, 8196				; 00002004H
	mov	edx, DWORD PTR _fdo$[ebp]
	mov	DWORD PTR [edx+28], ecx

; 158  : 	fdo->Flags &= ~DO_DEVICE_INITIALIZING;

	mov	eax, DWORD PTR _fdo$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	and	ecx, -129				; ffffff7fH
	mov	edx, DWORD PTR _fdo$[ebp]
	mov	DWORD PTR [edx+28], ecx

; 159  : 
; 160  : 	status = PsCreateSystemThread(&pdx->hExternThread,
; 161  : 			THREAD_ALL_ACCESS,
; 162  : 			NULL,  
; 163  : 			NULL,  
; 164  : 			NULL,  
; 165  : 			ExternWorkThread,//调用的函数  
; 166  : 			pdx
; 167  : 		);

	mov	eax, DWORD PTR _pdx$[ebp]
	push	eax
	push	OFFSET _ExternWorkThread@4
	push	0
	push	0
	push	0
	push	2097151					; 001fffffH
	mov	ecx, DWORD PTR _pdx$[ebp]
	add	ecx, 24					; 00000018H
	push	ecx
	call	DWORD PTR __imp__PsCreateSystemThread@28
	mov	DWORD PTR _status$[ebp], eax

; 168  : 
; 169  : 	KdPrint(("Leave HelloWDMAddDevice\n"));

	push	OFFSET ??_C@_0BJ@GNFEGBFC@Leave?5HelloWDMAddDevice?6?$AA@NNGAKEGL@
	call	_DbgPrint
	add	esp, 4

; 170  : 	return status;

	mov	eax, DWORD PTR _status$[ebp]
$LN4@HelloWDMAd:

; 171  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?HelloWDMAddDevice@@YGJPAU_DRIVER_OBJECT@@PAU_DEVICE_OBJECT@@@Z ENDP ; HelloWDMAddDevice
PAGE	ENDS
; Function compile flags: /Odtp
; File c:\program files\windows kits\8.0\include\km\wdm.h
;	COMDAT _IoSkipCurrentIrpStackLocation@4
_TEXT	SEGMENT
tv72 = -4						; size = 4
_Irp$ = 8						; size = 4
_IoSkipCurrentIrpStackLocation@4 PROC			; COMDAT

; 28682: {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 28683:     NT_ASSERT(Irp->CurrentLocation <= Irp->StackCount);

	mov	eax, DWORD PTR _Irp$[ebp]
	movsx	ecx, BYTE PTR [eax+35]
	mov	edx, DWORD PTR _Irp$[ebp]
	movsx	eax, BYTE PTR [edx+34]
	cmp	ecx, eax
	jle	SHORT $LN3@IoSkipCurr
__annotation$5:
	int	44					; 0000002cH
	mov	DWORD PTR tv72[ebp], 0
	jmp	SHORT $LN4@IoSkipCurr
$LN3@IoSkipCurr:
	mov	DWORD PTR tv72[ebp], 1
$LN4@IoSkipCurr:

; 28684:     Irp->CurrentLocation++;

	mov	ecx, DWORD PTR _Irp$[ebp]
	mov	dl, BYTE PTR [ecx+35]
	add	dl, 1
	mov	eax, DWORD PTR _Irp$[ebp]
	mov	BYTE PTR [eax+35], dl

; 28685:     Irp->Tail.Overlay.CurrentStackLocation++;

	mov	ecx, DWORD PTR _Irp$[ebp]
	mov	edx, DWORD PTR [ecx+96]
	add	edx, 36					; 00000024H
	mov	eax, DWORD PTR _Irp$[ebp]
	mov	DWORD PTR [eax+96], edx

; 28686: }

	mov	esp, ebp
	pop	ebp
	ret	4
_IoSkipCurrentIrpStackLocation@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files\windows kits\8.0\include\km\wdm.h
;	COMDAT _IoGetCurrentIrpStackLocation@4
_TEXT	SEGMENT
tv73 = -4						; size = 4
_Irp$ = 8						; size = 4
_IoGetCurrentIrpStackLocation@4 PROC			; COMDAT

; 28035: {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 28036:     NT_ASSERT(Irp->CurrentLocation <= Irp->StackCount + 1);

	mov	eax, DWORD PTR _Irp$[ebp]
	movsx	ecx, BYTE PTR [eax+35]
	mov	edx, DWORD PTR _Irp$[ebp]
	movsx	eax, BYTE PTR [edx+34]
	add	eax, 1
	cmp	ecx, eax
	jle	SHORT $LN3@IoGetCurre
__annotation$5:
	int	44					; 0000002cH
	mov	DWORD PTR tv73[ebp], 0
	jmp	SHORT $LN4@IoGetCurre
$LN3@IoGetCurre:
	mov	DWORD PTR tv73[ebp], 1
$LN4@IoGetCurre:

; 28037:     return Irp->Tail.Overlay.CurrentStackLocation;

	mov	ecx, DWORD PTR _Irp$[ebp]
	mov	eax, DWORD PTR [ecx+96]

; 28038: }

	mov	esp, ebp
	pop	ebp
	ret	4
_IoGetCurrentIrpStackLocation@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\lw8172\documents\github\hooktestbed\wdmdrivertest\wdmdrivertest\utils.h
;	COMDAT ??3@YAXPAX@Z
_TEXT	SEGMENT
_pointer$ = 8						; size = 4
??3@YAXPAX@Z PROC					; operator delete, COMDAT

; 26   : {

	npad	2
	push	ebp
	mov	ebp, esp

; 27   : 	ExFreePool(pointer);

	mov	eax, DWORD PTR _pointer$[ebp]
	push	eax
	call	DWORD PTR __imp__ExFreePool@4

; 28   : }

	pop	ebp
	ret	0
??3@YAXPAX@Z ENDP					; operator delete
_TEXT	ENDS
END
